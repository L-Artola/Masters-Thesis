---
title: "without lags"
output: html_document
---

```{r setup, include=FALSE}

rm(list=ls())


library(tidyverse)
library(dplyr)
library(ggrepel)
library(knitr)
library(caret)
library(ranger)
library(glmnet)
library(e1071)
library(varImp)
library(MLeval)
library(DMwR)
library(ROSE)
library(MLmetrics)

library(moments)

library(doParallel)





```

 

# Read in Cleaned Data Set
```{R}

CQD_final_set <- read.csv("CQD_final_set.csv")

```


Total Risk Based capital Ratio	(rbc1aaj)
Leverage ratio	(rbcrwaj)
Equity capital to assets	(eqv)
Net loans and leases to total assets	(lnlsntv)
Return on equity	(roe)
Return on assets	(roa)
Net operating income to assets	(noijy)
Net interest margin	(nimy)
Net Charge-offs to loans	(ntlnlsr)
Noninterest income to average assets	(noniiay)
Efficency Ratio	(eeffr)
Loan lease allowance to loans	(lnatresr)
Noncurrent assets plus other real estate	(nperfv)
Non-current loans to loans	(nclnlsr)
net loans and leases to core deposits	(idlncorr)
Cost of funding earning assets 	(intexpy)


# Functions for Macro F1
```{r}

# Precision Macro
Precision_macro <- function(y_true, y_pred, labels = NULL) {
  Confusion_DF <- ConfusionDF(y_pred, y_true)
  
  if (is.null(labels) == TRUE) labels <- unique(c(y_true, y_pred))

  
  Prec <- c()
  for (i in c(1:length(labels))) {
    positive <- labels[i]
    

    tmp <- Confusion_DF[which(Confusion_DF$y_true==positive & Confusion_DF$y_pred==positive), "Freq"]
    TP <- if (length(tmp)==0) 0 else as.integer(tmp)
    tmp <- Confusion_DF[which(Confusion_DF$y_true!=positive & Confusion_DF$y_pred==positive), "Freq"]
    FP <- if (length(tmp)==0) 0 else as.integer(sum(tmp))
    
    Prec[i] <- TP/(TP+FP)
  }
  Prec[is.na(Prec)] <- 0
  Precision_macro <- mean(Prec) 
  return(Precision_macro)
}

# Recall Macro

Recall_macro <- function(y_true, y_pred, labels = NULL) {
  Confusion_DF <- ConfusionDF(y_pred, y_true)
  
  if (is.null(labels) == TRUE) labels <- unique(c(y_true, y_pred))

  
  Rec <- c()
  for (i in c(1:length(labels))) {
    positive <- labels[i]
    

    tmp <- Confusion_DF[which(Confusion_DF$y_true==positive & Confusion_DF$y_pred==positive), "Freq"]
    TP <- if (length(tmp)==0) 0 else as.integer(tmp)
    
    tmp <- Confusion_DF[which(Confusion_DF$y_true==positive & Confusion_DF$y_pred!=positive), "Freq"]
    FN <- if (length(tmp)==0) 0 else as.integer(sum(tmp))
    
    Rec[i] <- TP/(TP+FN)
  }

  Rec[is.na(Rec)] <- 0
  Recall_macro <- mean(Rec)
  return(Recall_macro)
}


# F1_Score_Macro
F1_Score_macro <- function(y_true, y_pred, labels = NULL) {
  if (is.null(labels) == TRUE) labels <- unique(c(y_true, y_pred)) 
  Precision <- Precision_macro(y_true, y_pred, labels)
  Recall <- Recall_macro(y_true, y_pred, labels)
  F1_Score_macro <- 2 * (Precision * Recall) / (Precision + Recall)
  return(F1_Score_macro)
}


```



# Train Test Split | 2 Year Out of Time Split
```{r}
# Make Solvency a factor
CQD_final_set$solvency <- as.factor(CQD_final_set$solvency)



#Out of time validation set 
outoftime <- CQD_final_set[grepl(c("2014|2013"), CQD_final_set$date),]
outoftime <- outoftime %>%
        select(!c(date, cert))



# Train/Test set
TT <- CQD_final_set[!grepl(c("2014|2013"), CQD_final_set$date),]
TT <- TT %>%
        select(!c(date, cert))

table(TT$solvency)
table(outoftime$solvency)
```



#Cartet Train Test split
```{r}

#Metrics
# ROC AUC
# Macro F-Meas (Only care about postives being picked correctly)
# Balanced Accuracy ( Cares if negatives and postives picked correctly)
# sensitivity TP/(TP/FN)
# Specificity
set.seed(111)

# Reverse Factor Levels
levels(TT$solvency) <- c("Solvent", "Insolvent")
TT$solvency <- factor(TT$solvency, levels=rev(levels(TT$solvency)))
                      
levels(outoftime$solvency) <- c("Solvent", "Insolvent")
outoftime$solvency <- factor(outoftime$solvency, levels=rev(levels(outoftime$solvency)))


train_split <- caret::createDataPartition(TT$solvency, p = 0.80, list = FALSE)
# Here we define a split index and we are now going to use a multiclass ML model to fit the data
train <- TT[train_split,]
test <- TT[-train_split,]


```

# Caret Downsample Penalized Logistic Regression
```{r}
# Following prior Research I used AUROC for selecting the most efficient parameterization
#We employed the accuracy metric
#(AUROC) in the validation sub-sample for selecting the
#most efficient parameterization.

set.seed(111)

down_train <- downSample(x = train[, -ncol(train)],
                         y = train$solvency)

table(down_train$Class)

start.time <- proc.time()
cl <- makePSOCKcluster(8)
registerDoParallel(cl, cores = 8)

set.seed(111)
ds_log = train(Class ~.,  
               data = down_train,
               method = "glmnet",
               trControl = trainControl(method = "cv", number = 10, classProbs = TRUE, savePredictions = TRUE, summaryFunction = twoClassSummary), 
               tuneLength = 100,
               preProcess = c("center", "scale"),
               family = "binomial",
               metric = "ROC")


stop.time <- proc.time()
run.time <- stop.time - start.time
print(run.time)
stopCluster(cl)



# Probability Threshold
probs <- seq(.1, 0.9, by = 0.02)
ths <- thresholder(ds_log,
                   threshold = probs,
                   final = TRUE,
                   statistics = "all")
ths

ggplot(ths, aes(x = prob_threshold, y = J)) + 
  geom_point()


ggplot(ths, aes(x = prob_threshold, y = Sensitivity)) + 
  geom_point() + 
  geom_point(aes(y = Specificity), col = "red")


######################
# Confusion Matrix on Train Set
predictions <- predict(ds_log, down_train, type = "raw")
predictions_1 <- cbind(data.frame(train_preds=predictions, 
                                down_train$Class))
cm <- confusionMatrix(predictions_1$train_preds, predictions_1$down_train.Class)
cm
F_meas(predictions_1$train_preds, predictions_1$down_train.Class)
predictions <- predict(ds_log, down_train, type = "prob")
test1 <- evalm(data.frame(predictions, down_train$Class), positive = "Insolvent")


# Confusion Matrix on test Set
predictions <- predict(ds_log, test, type = "raw")
predictions_1 <- cbind(data.frame(train_preds=predictions, 
                                test$solvency))
F_meas(predictions_1$train_preds, predictions_1$test.solvency)
F1_Score_macro(predictions_1$test.solvency, predictions_1$train_preds)
cm <- confusionMatrix(predictions_1$train_preds, predictions_1$test.solvency)
cm
predictions <- predict(ds_log, test, type = "prob")
test1 <- evalm(data.frame(predictions, test$solvency), positive = "Insolvent")


# Confusion Matrix on out of time Set
predictions <- predict(ds_log, outoftime, type = "raw")
predictions_1 <- cbind(data.frame(train_preds=predictions, 
                                outoftime$solvency))
F_meas(predictions_1$train_preds, predictions_1$outoftime.solvency)
F1_Score_macro(predictions_1$outoftime.solvency, predictions_1$train_preds)
cm <- confusionMatrix(predictions_1$train_preds, predictions_1$outoftime.solvency)
cm
predictions <- predict(ds_log, outoftime, type = "prob")
test1 <- evalm(data.frame(predictions, outoftime$solvency), positive = "Insolvent")





```


# Smote Log reg
```{r}
# Need to play with Smote
set.seed(111)
smote_train <- SMOTE(solvency~., data = train)
table(smote_train$Class)


start.time <- proc.time()
cl <- makePSOCKcluster(8)
registerDoParallel(cl, cores = 8)

set.seed(111)
smote_log = train(solvency ~.,  
               data = smote_train,
               method = "glmnet",
               trControl = trainControl(method = "cv", number = 10, classProbs = TRUE, savePredictions = TRUE, summaryFunction = twoClassSummary), 
               tuneLength = 10,
               preProcess = c("center", "scale"),
               family = "binomial",
               metric = "ROC")



stop.time <- proc.time()
run.time <- stop.time - start.time
print(run.time)
stopCluster(cl)


######################
# Confusion Matrix on Train Set
predictions <- predict(smote_log, smote_train, type = "raw")
predictions_1 <- cbind(data.frame(train_preds=predictions, 
                                smote_train$solvency))
F_meas(predictions_1$train_preds, predictions_1$smote_train.solvency)
cm <- confusionMatrix(predictions_1$train_preds, predictions_1$smote_train.solvency)
cm
predictions <- predict(smote_log, smote_train, type = "prob")
test1 <- evalm(data.frame(predictions, smote_train$solvency), positive = "Insolvent")


# Confusion Matrix on Test Set
predictions <- predict(smote_log, test, type = "raw")
predictions_1 <- cbind(data.frame(train_preds=predictions, 
                                test$solvency))
F_meas(predictions_1$train_preds, predictions_1$test.solvency)
F1_Score_macro(predictions_1$test.solvency, predictions_1$train_preds)
cm <- confusionMatrix(predictions_1$train_preds, predictions_1$test.solvency)
cm
predictions <- predict(smote_log, test, type = "prob")
test1 <- evalm(data.frame(predictions, test$solvency), positive = "Insolvent")


# Confusion Matrix on out of time Set
predictions <- predict(smote_log, outoftime, type = "raw")
predictions_1 <- cbind(data.frame(train_preds=predictions, 
                                outoftime$solvency))
F_meas(predictions_1$train_preds, predictions_1$outoftime.solvency)
F1_Score_macro(predictions_1$outoftime.solvency, predictions_1$train_preds)
cm <- confusionMatrix(predictions_1$train_preds, predictions_1$outoftime.solvency)
cm
predictions <- predict(smote_log, outoftime, type = "prob")
test1 <- evalm(data.frame(predictions, outoftime$solvency), positive = "Insolvent")


```



# Rose Log Reg
```{r}
set.seed(111)
rose_train <- ROSE(solvency~., data = train)$data
table(rose_train$solvency)

start.time <- proc.time()
cl <- makePSOCKcluster(8)
registerDoParallel(cl, cores = 8)

set.seed(111)
rose_log = train(solvency ~.,  
               data = rose_train,
               method = "glmnet",
               trControl = trainControl(method = "cv", number = 10, classProbs = TRUE, savePredictions = TRUE, summaryFunction = twoClassSummary), 
               tuneLength = 10,
               preProcess = c("center", "scale"),
               family = "binomial",
               metric = "ROC")



stop.time <- proc.time()
run.time <- stop.time - start.time
print(run.time)
stopCluster(cl)


######################
# Confusion Matrix on Train Set
predictions <- predict(rose_log, rose_train, type = "raw")
predictions_1 <- cbind(data.frame(train_preds=predictions, 
                                rose_train$solvency))

cm <- confusionMatrix(predictions_1$train_preds, predictions_1$rose_train.solvency)
cm
F_meas(predictions_1$train_preds, predictions_1$rose_train.solvency)
predictions <- predict(rose_log, rose_train, type = "prob")
test1 <- evalm(data.frame(predictions, rose_train$solvency), positive = "Insolvent")

# Confusion Matrix on Test Set
predictions <- predict(rose_log, test, type = "raw")
predictions_1 <- cbind(data.frame(train_preds=predictions, 
                                test$solvency))
F1_Score_macro(predictions_1$test.solvency, predictions_1$train_preds)
F_meas(predictions_1$train_preds, predictions_1$test.solvency)
cm <- confusionMatrix(predictions_1$train_preds, predictions_1$test.solvency)
cm
predictions <- predict(rose_log, test, type = "prob")
test1 <- evalm(data.frame(predictions, test$solvency), positive = "Insolvent")

# Confusion Matrix on out of time Set
predictions <- predict(rose_log, outoftime, type = "raw")
predictions_1 <- cbind(data.frame(train_preds=predictions, 
                                outoftime$solvency))
F_meas(predictions_1$train_preds, predictions_1$outoftime.solvency)
F1_Score_macro(predictions_1$outoftime.solvency, predictions_1$train_preds)
cm <- confusionMatrix(predictions_1$train_preds, predictions_1$outoftime.solvency)
cm
predictions <- predict(rose_log, outoftime, type = "prob")
test1 <- evalm(data.frame(predictions, outoftime$solvency), positive = "Insolvent")


```





























